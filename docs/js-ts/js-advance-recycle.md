---
nav: Js
group: 进阶
toc: content
title: GC
---

## GC 垃圾回收

GC 工作时应用是停止的  
频繁的过长的 GC 会导致应用假死  
用户使用过程中干到卡顿

GC 即 Garbage Collection ，程序工作过程中会产生很多 垃圾，这些垃圾是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的，这一套引擎执行而对我们又相对无感的操作也就是常说的 垃圾回收机制 了

当然也不是所有语言都有 GC，一般的高级语言里面会自带 GC，比如 Java、Python、JavaScript 等，也有无 GC 的语言，比如 C、C++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦

```js
let test = {
  name: 'isboyjc',
};
test = [1, 2, 3, 4, 5];
```

<a target="_blank" href="https://juejin.cn/post/7280787122016059426">参考</a>

在说垃圾回收之前，我们首先需要了解的是，什么是垃圾？为什么要进行垃圾回收？

垃圾：  JS 中的函数，变量，对象等都需要占用一定的内存，当这些东西不再被使用的时候，就变成了垃圾

1、已经调用完毕的函数作用域及其内部的值<br/>
2、值为 null 值<br/>
3、无法被访问到的值<br/>

注意：全局变量一般不会回收（关闭页面时回收）；一般情况下局部变量的值，不用了，会被自动回收掉。<br/>

垃圾回收策略：<br/>

### 标记清除 （JavaScript 最常用的垃圾收回机制）

`2012 年起，所有现代浏览器都使用了标记清除法`

标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。<br/>
缺点<br/>
a、内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。<br/>
b、分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。<br/>

而 V8 中就采用了我们上文中说的`标记整理`算法来解决这一问题来优化空间

V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。<br/>

针对新生区采用并行回收。<br/>
针对老生区采用增量标记与惰性回收<br/>

#### 并行回收

所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作

简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了

不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同，实现起来也很简单

新生代对象空间就采用并行策略，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收

#### 增量标记与懒性清理

我们上面所说的并行策略虽然可以增加垃圾回收的效率，对于新生代垃圾回收器能够有很好的优化，但是其实它还是一种全停顿式的垃圾回收方式，对于老生代来说，它的内部存放的都是一些比较大的对象，对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间

所以为了减少全停顿的时间，在 2011 年，V8 对老生代的标记进行了优化，从全停顿标记切换到增量标记

什么是增量
增量就是将一次 GC 标记的过程，分成了很多小步，每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成一轮 GC 标记

可以看出增量的实现要比并行复杂一点，V8 对这两个问题对应的解决方案分别是三色标记法与写屏障

懒性清理

增量标记完成后，惰性清理就开始了。当增量标记完成后，假如当前的可用内存足以让我们快速的执行代码，其实我们是没必要立即清理内存的，可以将清理过程稍微延迟一下，让 JavaScript 脚本代码先执行，也无需一次性清理完所有非活动对象内存，可以按需逐一进行清理直到所有的非活动对象内存都清理完毕，后面再接着执行增量标记

这就要说到并发回收了，它指的是主线程在执行 JavaScript 的过程中，辅助线程能够在后台完成执行垃圾回收的操作，辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起

辅助线程在执行垃圾回收的时候，主线程也可以自由执行而不会被挂起，这是并发的优点，但同样也是并发回收实现的难点，因为它需要考虑主线程在执行 JavaScript 时，堆中的对象引用关系随时都有可能发生变化，这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变，所以它需要额外实现一些读写锁机制来控制这一点，这里我们不再细说

### 引用计数

它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收

缺点：<br/>
a、需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。<br/>
b、解决不了循环引用导致的无法回收问题<br/>
`在 2012 年以后所有现代浏览器都取消这种算法了，取而代之的是标记清除法`<br/>
如果存在循环引用的对象，会出现严重的内存泄漏

引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾

```js
let obj1 = { name: 'test' }; // 创建一个对象，被 obj1 所引用，计数为 1
let obj2 = obj1; // obj2 变量是第二个对该对象的引用，计数为 2
obj1 = null; // 该对象的原始引用 obj1 已经没有了，计数为 1
obj2 = null; // 此时对象所有引用都没有了，计数为 0，垃圾回收机制回收该对象
```

```js
function func() {
  let obj1 = {};
  let obj2 = {};
  obj1.a = obj2;
  obj2.a = obj1;
  return 1;
}
```

### 分代回收 （v8 所采用的的垃圾回收机制）

分代回收是一种结合了标记清除和引用计数的垃圾回收机制，它会根据对象的生命周期将内存分为不同的代。  
老生代实际上就是上面说到的标记清除算法，这套算法适用于存活时间较长的对象

新生代堆（存活时间比较短）被分为两个相等大小的区域：From 空间和 To 空间

新对象分配到 From 空间  
当 From 空间满时，触发垃圾回收  
从根对象开始，标记所有存活的对象  
将存活的对象复制到 To 空间中  
清除已经死亡的对象  
将 To 空间作为新的 From 空间，并将 From 空间作为新的 To 空间，完成垃圾回收

## 说说你对 V8 引擎的了解

V8 引擎是 Google 开发的一个开源 JavaScript 引擎，广泛应用于 Chrome 浏览器和 Node.js。它主要负责将 JavaScript 代码转换为高效的机器代码，以便快速执行。


###  V8 的内存限制是多少, 为什么 V8 这样设计
64 位操作系统  
内存限制为 1.4 个 g

32 位操作系统  
700 兆

开发者可通过 --max-old-space-size 参数调整 单位是 MB。
例子：   
node --max-old-space-size=4096 app.js  （4GB）

1. 避免单个 JavaScript 进程无限制占用系统内存
2. 性能和效率的权衡,堆空间太大管理起来垃圾回收成本增高
3. 安全和隔离性考虑


### 如何查看 V8 的内存使用情况
process.memoryUsage()
```js
{
  rss: 4935680,
  heapTotal: 1826816,
  heapUsed: 650472,
  external: 49879
}
```

heapTotal 和 heapUsed 代表 V8 的内存使用情况。external 代表 V8 管理的，绑定到 Javascript 的 C++对象的内存使用情况。rss, 驻留集大小, 是给这个进程分配了多少物理内存(占总分配内存的一部分) 这些物理内存中包含堆，栈，和代码段。


## 什么是内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。  
有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。

## 常见内存泄露情况

1. 意外的全局变量

```js
function foo(arg) {
  bar = 'this is a hidden global variable';
}
```

2. 另一种意外的全局变量可能由 this 创建：

```js
function foo() {
  this.variable = 'potential accidental global';
}
// foo 调用自己，this 指向了全局对象（window）
foo();
```

上述使用严格模式，可以避免意外的全局变量

3. 定时器也常会造成内存泄露

   如果 id 为 Node 的元素从 DOM 中移除，该定时器仍会存在，同时，因为回调函数中包含对 someResource 的引用，定时器外面的 someResource 也不会被释放

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        // 处理 node 和 someResource
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
```

4. 包括我们之前所说的闭包，维持函数内局部变量，使其得不到释放

```js
function bindEvent() {
  var obj = document.createElement('XXX');
  var unused = function () {
    console.log(obj, '闭包内引用obj obj不会被释放');
  };
  obj = null; // 解决方法
}
```

5. 没有清理对 DOM 元素的引用同样造成内存泄露

```js
const refA = document.getElementById('refA');
document.body.removeChild(refA); // dom删除了
console.log(refA, 'refA'); // 但是还存在引用能console出整个div 没有被回收
refA = null;
console.log(refA, 'refA'); // 解除引用
```

6. 括使用事件监听 addEventListener 监听的时候，在不监听的情况下使用 removeEventListener 取消对事件监听
